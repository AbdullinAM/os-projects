# Задание

1. В загрузочный сектор поместить программу вывода на экран произвольного сообщения. Программу написать на ассемблере (предпочтительно встраиваемом в стандартную конфигурацию ) и на С (при необходимости допустимы ассемблерные вставки), убедиться в работоспособности обоих вариантов. См. пример кода ниже. В качестве носителя предпочтителен выбор флэш. Начать можно с экспериментов над виртуальной дискетой, как показано ниже.
2. Создать первичный загрузчик для виртуального, а затем реального носителя, (пример показан для виртуальной дискеты и ФС FAT12/16), который будет находить файл программы на носителе и загружать ее на выполнение. Сделать 2 варианта на разных языках (asm и С). Привести весь план экспериментов и результаты их проведения в виде «логфайлов» и screenshot –ов. ФС можно выбрать на свое усмотрение.

# Описание для выполнения задания

Загрузка системы 1)начинается с того, что BIOS считывает **первый сектор** блочного носителя, например, жесткого диска, 2)размещает его в памяти (ОЗУ) по адресу 0000:7С00h и 3)передает туда управление.

Этот сектор называется главным загрузочным сектором (Master Boot Record, сокращенно MBR). В начале записи MBR расположен код загрузчика.

Следом за ним идет таблица разделов, описывающая схему разбиения логических дисков.

В конце сектора находится сигнатура 55h AAh, подтверждающая, что это действительно MBR.

Если хотя бы один из двух последних байтов отличается по значению, считается, что первый сектор не является MBR и не содержит осмысленной информации.

BIOS загружает MBR по адресу 7C00h, поэтому в начале ассемблерного кода должна стоять директива ORG 7C00h. Кроме того, необходимо указать директиву USE16, потому что **загрузчик выполняется в 16-разряном режиме**.

Попробуем реализовать на ассемблере простейшую программу, которая выводит приветственное сообщение на экран, и поместим ее в загрузочный сектор.

## 1. Пример реализации вывода сообщения из **MBR**

Текст программы:

```
use16
org  0x7C00
; Очищаем регистры
        xor        ax, ax
 mov es, ax
 mov ds, ax

 mov ss, ax
        mov        sp, 0x1000
; Установим видеорежим, очистка экрана
 mov ax, 3
 int 10h
; Вывод приветственного сообщения
 mov si, mHello
 call print
; Зависаем в бесконечном цикле
die: jmp short die
mHello db &#39;Hello, world - i was booted!&#39;,10,13,0
; Подпрограммавывода
print:
 cld
 pusha
.PrintChar:
 lodsb
 test al, al
 jz short .Exit
 mov ah, 0eh
 mov bl, 7
 int 10h
 jmp short .PrintChar
.Exit:
        popa
 ret
```

Компилируем  программу:
```
&gt;nasm -f bin boothi.asm -o boothi
```
Мы получили исполняемый код (файл **boothi** ). Теперь можно записать его в MBR раздел дискеты и, при загрузке с этой дискеты, мы увидим на экране приветственное сообщение.

 ![img1](img1.png)

Реализованная программа делает то, что нам надо – выводит приветственное сообщение на экран при загрузке. Однако загрузчиком она не является.

## 2. Пример реализации первичного загрузчика для дискеты с поиском файла в ФС **FAT**  и **загрузкой на выполнение**

Рассмотрим теперь реализацию первичного загрузчика для дискеты, который будет находить файл этой программы и загружать ее на выполнение.

Для этого необходимо работать с файловой системой.  Заголовок файловой системы FAT содержит всю необходимую информацию о файловой системе и находится в первом секторе дискеты, благодаря чему он загружается вместе с загрузчиком. Первичный загрузчик будет искать в корневом каталоге исполняемый файл программы, загрузит его в память и передаст управление на его начало.

В начале загрузочного сектора располагается заголовок FAT:

```
; Общая часть для всех типов FAT
BS\_jmpBoot:
jmp short BootStart ; Переходим на код загрузчика
nop
BS\_OEMName        db &#39;\*-v4VIHC&#39;        ; 8 байт, (что было на моей дискете)
BPB\_BytsPerSec dw 0x200 ; Байт на сектор
BPB\_SecPerClus db 1 ; Секторов на кластер
BPB\_RsvdSecCnt dw 1 ; Число резервных секторов
BPB\_NumFATs db 2 ; Количектво копий FAT
BPB\_RootEntCnt dw 224 ; Элементов в корневом катологе (max)
BPB\_TotSec16 dw 2880 ; Всего секторов или 0
BPB\_Media db 0xF0 ; код типа устройства
BPB\_FATsz16 dw 9 ; Секторов на элемент таблицы FAT
BPB\_SecPerTrk dw 18 ; Секторов на дорожку
BPB\_NumHeads dw 2 ; Число головок
BPB\_HiddSec dd 0 ; Скрытых секторов
BPB\_TotSec32 dd 0 ; Всего секторов или 0
; Заголовок для FAT12 и FAT16
BS\_DrvNum db 0 ; Номер дика для прерывания int 0x13
BS\_ResNT db 0 ; Зарезервировано для Windows NT
BS\_BootSig db 29h ; Сигнатура расширения
BS\_VolID dd 2a876CE1h ; Серийный номер тома
BS\_VolLab db &#39;X boot disk&#39; ; 11 байт, метка тома
BS\_FilSysType        db &#39;FAT12   &#39;        ; 8 байт, типФС
; Структура элемента каталога
struc DirItem
 DIR\_Name: resb 11
        DIR\_Attr:        resb 1
 DIR\_ResNT: resb 1
 DIR\_CrtTimeTenth resb 1
 DIR\_CrtTime: resw 1
        DIR\_CrtDate:        resw 1
 DIR\_LstAccDate: resw 1
 DIR\_FstClusHi: resw 1
 DIR\_WrtTime: resw 1
 DIR\_WrtDate: resw 1
 DIR\_FstClusLow: resw 1
        DIR\_FileSize:        resd 1
endstruc ;DirItem
```
Загрузчик BIOS передает управление на начало загрузочного сектора, то есть на BS\_jmpBoot, поэтому в начале заголовка FAT отводится 3 байта для короткой или длинной инструкции jmp. В данном случае используется короткая и пустая операция nop. Таким образом, мы «прыгаем» на наш код.

Описываем переменные и очищаем регистры:
```
; Не инициализированные переменные
; При инициализации они затрут не нужные поля заголовка FAT: BS\_jmpBoot и BS\_OEMName
struc NotInitData
 SysSize: resd 1 ; Размер системной области FAT
 fails: resd 1 ; Число неудачных попыток при чтении
 fat: resd 1 ; Номер загруженного сектора с элементами FAT
endstruc ;NotInitData
; По этому адресу мы будем загружать загрузчик
%define SETUP\_ADDR 0x1000
; А по этому адресу нас должны были загрузить
%define BOOT\_ADDR 0x7C00
%define BUF 0x500
BootStart:
 cld
 xor cx, cx
 mov ss, cx
 mov es, cx
        mov        ds, cx
 mov sp, BOOT\_ADDR
 mov bp, sp
        ; Сообщим о том что мы загружаемся
        mov        si, BOOT\_ADDR + mLoading
 call print
```
Все сегментные регистры настраиваем на начало физической памяти, вершину стека настраиваем на начало сектора.

(Процедуру print, выводящую сообщение на экран, см.ниже)

Теперь нужно вычислить номера первых секторов корневого каталога и данных файлов:
```
        mov        al, [byte bp+BPB\_NumFATs]
 cbw
 mul word [byte bp+BPB\_FATsz16]
 add ax, [byte bp+BPB\_HiddSec]
 adc dx, [byte bp+BPB\_HiddSec+2]
        add        ax, [byte bp+BPB\_RsvdSecCnt]
 adc dx, cx
 mov si, [byte bp+BPB\_RootEntCnt]
        ; dx:ax - Номер первого сектора корневого каталога
 ; si - Количество элементов в корневом каталоге
 pusha
 ; Вычислим размер системной области FAT = резервные сектора +
 ; все копии FAT + корневой каталог
 mov [bp+SysSize], ax ; осталось добавить размер каталога
 mov [bp+SysSize+2], dx
 ; Вычислим размер корневого каталога
 mov ax, 32
 mul si
 ; dx:ax - размер корневого каталога в байтах, а надо в секторах
        mov        bx, [byte bp+BPB\_BytsPerSec]
        add        ax, bx
 dec ax
 div bx
        ; ax - размер корневого каталога в секторах
 add [bp+SysSize], ax ; Теперь мы знаем размер системной
 adc [bp+SysSize+2], cx ; области FAT, и начало области данных
 popa
 ; В dx:ax - снова номер первого сектора корневого каталога
 ; si - количество элементов в корневом каталоге
```
Просматриваем корневой каталог в поисках нужного файла:
```
NextDirSector:
 ; Загрузим очередной сектор каталога во временный буфер
 mov bx, 700h ; es:bx - буфер для считываемого сектора
 mov di, bx ; указатель текущего элемента каталога
 mov cx, 1 ; количество секторов для чтения
        call        ReadSectors
        jc        near DiskError        ; ошибкапричтении
RootDirLoop:
        ; Ищемнашфайл
        ; cx = 0 послефункции ReadSectors
 cmp [di], ch ; byte ptr [di] = 0?
        jz        near NotFound        ; Да, это последний элемент в каталоге
 ; Нет, не последний, сравним имя файла
 pusha
 mov cl, 11 ; длина имени файла с расширением
 mov si, BOOT\_ADDR + LoaderName ; указатель на имя искомого файла
 rep cmpsb ; сравниваем
 popa
 jz short Found ; Нашли, выходим из цикла
 ; Нет, ищем дальше
 dec si ; RootEntCnt
 jz near NotFound ; Это был последний элемент каталога
 add di, 32 ; Переходим к следующему элементу каталога
 ; bx указывает на конец прочтенного сектора после call ReadSectors
 cmp di, bx ; Последний элемент в буфере?
 jb short RootDirLoop ; Нет, проверим следующий элемент
 jmp short NextDirSector ; Да последний, загрузим следующий сектор
```
В результате возможны следующие варианты: ошибка при чтении (метка DiskError), файл найден (метка Found), файл не найден (метка NotFound).

Если файл найден, то загружаем его в память и передаем управление на его начало:
```
Found:
 ; Загрузка загрузчика (извините, каламбур)
 mov bx, SETUP\_ADDR
 mov ax, [byte di+DIR\_FstClusLow] ; Номер первого кластера файла
 ; Загружаем сектор с элемнтами FAT, среди которых есть FAT[ax]
 ; LoadFAT сохраняет значения всех регистров
 call LoadFAT
ReadCluster:
 ; ax - Номер очередного кластера
 ; Загрузим его в память
 push ax
 ; Первые два элемента FAT служебные
 dec ax
 dec ax
 ; Число секторов для чтения
 ; cx = 0 после ReadSectors
 mov cl, [byte bp+BPB\_SecPerClus] ; Секторов на кластер
 mul cx
 ; dx:ax - Смещение кластера относительно области данных
        add        ax, [byte bp+SysSize]
 adc dx, [byte bp+SysSize+2]
        ; dx:ax - Номер первого сектора требуемого кластера
 ; cx еще хранит количество секторов на кластер
 ; es:bx - конец прошлого кластера и начало нового
 call ReadSectors ; читаем кластер
 jc near DiskError ; Увы, ошибка чтения
 pop ax ; Номер кластера
 ; Это конец файла?
 ; Получим значение следующего элемента FAT
 pusha
 ; Вычислим адрес элемента FAT
 mov bx, ax
        shl        ax, 1
 add ax, bx
 shr ax, 1
        ; Получим номер сектора, в котором находится текущий элемент FAT
        cwd
 div word [byte bp+BPB\_BytsPerSec]
        cmp        ax, [bp+fat]        ; Мы уже читали этот сектор?
 popa
 je Checked ; Да, читали
 ; Нет, надо загрузить этот сектор
 call LoadFAT
Checked:
 ; Вычислим адрес элемента FAT в буфере
        push        bx
 mov bx, ax
 shl bx, 1
 add bx, ax
 shr bx, 1
        and        bx, 511        ; остаток от деления на 512
 mov bx, [bx+0x700] ; а вот и адрес
 ; Извлечем следующий элемент FAT
 ; В FAT16 и FAT32 все немного проще :(
        test        al, 1
 jnz odd
 and bx, 0xFFF
 jmp short done
odd:
 shr bx, 4
done:
 mov ax, bx
 pop bx
        ; bx - новыйэлемент FAT
        cmp        ax, 0xFF8        ; EOF - конецфайла?
        jb        ReadCluster        ; Нет, читаем следующий кластер
 ; Наконец-то загрузили
 mov ax, SETUP\_ADDR&gt;&gt;4 ; SETUP\_SEG
        mov        es, ax
 mov ds, ax
        ; Передаем управление, наше дело сделано :)
 jmp SETUP\_ADDR&gt;&gt;4:0
LoadFAT:
; Процедура для загрузки сектора с элементами FAT
; Элемент ax должен находится в этом секторе
; Процедура не должна менять никаких регистров
 pusha
 ; Вычисляем адрес слова содержащего нужный элемент
        mov        bx, ax
 shl ax, 1
 add ax, bx
 shr ax, 1
 cwd
 div word [byte bp+BPB\_BytsPerSec]
        ; ax - смещение сектора относительно начала таблицы FAT
 mov [bp+fat], ax ; Запомним это смещение, dx = 0
 cwd   ; dx:ax - номер сектора, содержащего FAT[?]
 ; Добавим смещение к первой копии таблицы FAT
 add ax, [byte bp+BPB\_RsvdSecCnt]
        adc        dx, 0
 add ax, [byte bp+BPB\_HiddSec]
 adc dx, [byte bp+BPB\_HiddSec+2]
        mov        cx, 1        ; Читаем один сектор. Можно было бы и больше, но не быстрее
        mov        bx, 700h        ; Адресбуфера
 call ReadSectors
        jc        DiskError        ; Ошибочкавышла
 popa
 ret
```
Теперь разберем **процедуру загрузки секторов**. Процедура получает номер сектора в dx:ax (нумерация с нуля) и преобразует его к формату CSH (цилиндр, сектор, сторона), который используется прерыванием BIOS int 0x13.
```
;
; \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
; Чтение секторов с диска
;
; Входные параметры:
;  dx:ax       - (LBA) номер сектора
;  cx          - количество секторов для чтения
;  es:bx       - адрес буфера
;
; Выходные параметры:
;  cx       - Количество не прочтенных секторов
;  es:bx    - Указывает на конец буфера
;  cf = 1   - Произошла ошибка при чтении
; \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
ReadSectors:
next\_sector:
 ; Читаем очередной сектор
 mov byte [bp+fails], 3 ; Количество попыток прочесть сектор
try:
 ; Очередная попытка
 pusha
 ; Преобразуем линейный адрес в CSH
        ; dx:ax = a1:a0
 xchg ax, cx  ; cx = a0
 mov ax, [byte bp+BPB\_SecPerTrk]
 xchg ax, si  ; si = Scnt
 xchg ax, dx  ; ax = a1
 xor dx, dx
 ; dx:ax = 0:a1
 div si  ; ax = q1, dx = c1
 xchg ax, cx  ; cx = q1, ax = a0
 ; dx:ax = c1:a0
 div si  ; ax = q2, dx = c2 = c
 inc dx  ; dx = Sector?
 xchg cx, dx  ; cx = c, dx = q1
 ; dx:ax = q1:q2
 div word [byte bp+BPB\_NumHeads] ; ax = C (track), dx = H
 mov dh, dl  ; dh = H
 mov ch, al
 ror ah, 2
 or cl, ah
        mov        ax, 0201h                ; ah=2 - номерфункции, al = 1 сектор
 mov dl, [byte bp+BS\_DrvNum]
 int 13h
 popa
        jc        Failure        ; Ошибкапричтении
        ; Номер следующего сектора
 inc ax
 jnz next
        inc        dx
next:
 add bx, [byte bp+BPB\_BytsPerSec]
        dec        cx        ; Все сектора прочтены?
 jnz next\_sector ; Нет, читаем дальше
return:
 ret
Failure:
        dec        byte [bp+fails]        ; Последняяпопытка?
        jnz        try        ; Нет, еще раз
 ; Последняя, выходим с ошибкой
 stc
 ret
```
Если файл не был найден или произошла ошибка, выводим соответствующее сообщение и уходим на бесконечный цикл:
```
; Сообщения об ошибках
NotFound: ; Файл не найден
        mov        si, BOOT\_ADDR + mLoaderNotFound
 call print
 jmp short die
DiskError: ; Ошибкачтения
 mov si, BOOT\_ADDR + mDiskError
 call print
 ;jmp short die
die:        ; Простоошибка
 mov si, BOOT\_ADDR + mReboot
 call print
\_die: jmp short \_die
```
Собственно сама **подпрограмма вывода сообщения на экран** и **строковые сообщения** :
```
; Вывод строки на экран
; ds:si - адрес строки
print:
 pusha
print\_char:
        lodsb        ; Читаемочереднойсимвол
        test        al, al        ; 0 - конец?
        jz        shortpr\_exit        ; Да конец
 ; Нет, выводим этот символ
 mov ah, 0eh
        mov        bl, 7
        int        10h
        jmp        shortprint\_char        ; Выводим следующий символ
pr\_exit:
        popa
        ret
;print        endp
; Строковые сообщения
mLoading db &#39;Loading...&#39;, 10,13,0
mDiskError db &#39;Disk I/O error&#39;, 10,13,0
mLoaderNotFound db &#39;Loader not found&#39;, 10,13,0
mReboot  db &#39;Reboot system&#39;, 10,13,0
; Выравнивание размера образа на 512 байт
times 499-($-$$) db 0
**В последних двух строках задается имя файла программы, которую мы ищем** , и пишется **сигнатура загрузочного сектора** :
LoaderName        db &#39;BOOTHI    &#39; ; Имя файла загрузчика
BootMagic dw 0xAA55 ; Сигнатура загрузочного сектора
Компилируем данную программу:
&gt;nasm -fbinboot.asm -oboot
```
Мы получили файл с машинным кодом boot. Теперь можно записать его в MBR раздел дискеты. Также необходимо скомпилированный файл предыдущей программы расположить в корне дискеты. Текст программы останется неизменным, за исключением того, что нет необходимости располагать ее по адресу 0x7C00 (убираем директиву org).

Теперь при помощи HEX-редактора записываем boot в загрузочный сектор дискеты и, при попытке загрузиться с нее, видим приветственное сообщение:

 ![img2](img2.png)

Это сообщение свидетельствует о том, что наш первичный загрузчик отработал правильно, нашел нашу программу на дискете и загрузил на выполнение. Далее целесообразно программу вывода сообщения заменить на более содержательный исполняемый код для демонстрации возможностей разработанного загрузчика и для выполнения следующих пунктов задания.

Для контроля можно в тексте самого загрузчика предусмотреть вывод дополнительного сообщения и проследить этапность выполнения загрузчика и загружаемой программы.

# Задание *(продолжение)*

1. **Разработать первичный загрузчик ОС**.
Это задача аналогичная предыдущей (п.2) с той разницей, что в качестве исполняемого файла, искомого на носителе выступает файл с ядром ОС.
1. **Создать мультизагрузчик** , обеспечивающий варианты выбора загружаемой на исполнение программы или ОС.
Для эксперимента можно использовать несколько собственных программ, включая программы из п.1 и 2.
1. Предложить **загрузчик** любой **прикладной программы** в стандартном режиме (не из MBR) (в ОС Linux). Для этого сначала _проанализировать загрузку_ программы и порождение процесса (/потока) из консоли и из процесса. Оценить эффективность реализации на 2-х языковых уровнях (asm, C). Попытаться заменить (перехватить) системный загрузчик на свой собственный. Описать эксперимент.
